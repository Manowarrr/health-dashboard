**Semantic Template for code generation and modification**


# MODULE_CONTRACT:
# PURPOSE: [Краткое описание основной ответственности и цели этого модуля на русском языке.
#           Какую проблему он решает в рамках большей системы?]
#           (Пример: Централизует конфигурационные параметры, такие как уровень логирования,
#           место вывода логов и расширение файлов патчей для AI-Patcher.)
# SCOPE: [Основные функциональные области или домены, за которые отвечает модуль, на русском.]
#        (Пример: конфигурация, логирование, файловый ввод-вывод)
# INPUT: [Опишите входные данные, если они есть у модуля в целом, на русском.
#         Часто "Нет" или "Переменные окружения", если модуль в основном предоставляет функции/классы.]
#         (Пример: Нет (значения определены как константы или загружаются из конфигурационного файла).)
# OUTPUT: [Опишите, что модуль предоставляет остальной системе, на русском.
#          (Пример: Константы LOG_LEVEL, LOG_OUTPUT; Класс AIConfig; Функция init_logger)]
# KEYWORDS_MODULE: [domain1, technology2, core_concept3, module_type4, pattern5]
#                  (Пример: [configuration, logging, constants, patch_files, settings_management])
# LINKS_TO_MODULE: [external_module1.py, service_api_endpoint, related_module2.py]
#                  (Перечень других модулей/сервисов, с которыми этот модуль
#                  значимо взаимодействует, или которые влияют на него.)
# LINKS_TO_SPECIFICATION: [перечисление пунктов ТЗ и постановных документов, которые касаются модуля] 

# MODULE_MAP:
# (Формат: ТИП [Краткое описание сущности на русском] => [имя_сущности_латиницей])
# (Example:
# FUNC [Инициализирует логгер приложения] => init_logger
# FUNC [Читает и разбирает файл патча] => read_patch_file
# CLASS [Управляет конфигурацией AI-Patcher] => AIConfig
#   METHOD [Загружает конфигурацию из файла] => load_from_file
# CONST [Уровень логирования по умолчанию для приложения] => DEFAULT_LOG_LEVEL
# )


# KEY_USE_CASES:
##   Освещает наиболее важные сценарии, в которых участвует этот модуль или его ключевые компоненты
##   Для Use Case использовать AAG-нотацию: Actor (Context) -> Action (Module's/Component's Role) -> Goal
# - [ComponentName1_or_Feature1]: [Actor1 (Context1)] -> [Action1] -> [Goal1]
# - [ComponentName2_or_Feature2]: [Actor2 (Context2)] -> [Action2] -> [Goal2]
# (Example:
# - init_logger: System (Startup) -> ConfigureGlobalLogger -> ApplicationLoggingReady
# - read_patch_file: User (ApplyPatch) -> LoadAndValidatePatchData -> PatchDataAvailable
# - AIConfig.load_from_file: Admin (Setup) -> LoadExternalConfig -> SystemSettingsApplied
# )

## За описанием заголовка идет секция импорта
import logging # Пример импорта для логирования


# START_FUNCTION_[FunctionName]
# CONTRACT:
# PURPOSE: [Краткое описание того, что функция делает, ее основная ответственность, на русском.]
# INPUTS:
#   - [имя_аргумента1]: [ТипДанных] - [Описание аргумента1 и его назначения, на русском.]
#   - [имя_аргумента2]: [ТипДанных] - [Описание аргумента2 и его назначения, на русском.]
#   - ...
# OUTPUTS:
#   - [ТипВозвращаемогоЗначения] - [Описание того, что функция возвращает и в каком виде, на русском.]
# SIDE_EFFECTS:
#   - [Описание побочного эффекта 1, на русском.]
#   - ...
# TEST_CONDITIONS_SUCCESS_CRITERIA:
#   - [Условие 1 для корректного выполнения, на русском.]
#   - [Условие 2, важное граничное условие, на русском.]
# LINKS_TO_SPECIFICATION: [перечисление пунктов ТЗ и постановных документов, которые касаются функции] 
# KEYWORDS: [Keyword1, KnowledgeDomain2, Pattern3, Technology4]
# LINKS: [RelatedFunction1, Module2, ExternalService3]

def @FunctionName -> [ReturnType]:
    """
    [Однострочное, очень краткое описание функции на русском - для быстрого понимания и векторного поиска.]
    """
    # ИНСТРУКЦИИ ПО ОФОРМЛЕНИЮ ЛОГИЧЕСКИХ БЛОКОВ И ЛОГИРОВАНИЮ ДЛЯ ИИ:
    #
    # 1. РАЗБИЕНИЕ НА ЛОГИЧЕСКИЕ БЛОКИ:
    #    - Код внутри функций и методов СЛЕДУЕТ разбивать на семантически завершенные логические блоки.
    #    - Каждый такой блок ДОЛЖЕН быть обрамлен парными якорями:
    #      `#START_[ИМЯ_БЛОКА_В_UPPER_SNAKE_CASE]: [Краткое описание назначения блока на русском.]`
    #      `... код блока ...`
    #      `#END_[ИМЯ_БЛОКА_В_UPPER_SNAKE_CASE]`
    #    - ИМЯ_БЛОКА должно быть уникальным в пределах всего проекта и отражать суть блока.
    #    - Описание должно кратко пояснять, что делает блок (3-7 слов).
    #    - Блоки могут быть вложенными, сохраняя ту же структуру якорей.
    #    - Это помогает структурировать код, улучшает его читаемость и позволяет ИИ точно работать
    #      с отдельными частями логики (например, для модификации или анализа).
    #
    # 2. РЕКОМЕНДАЦИИ ПО ЛОГИРОВАНИЮ ВНУТРИ БЛОКОВ:
    # 2.1 ОБ ИНИЦИАЛИЗАЦИЯ ЛОГГЕРА (ВАЖНО!):
    #    - В начале каждого модуля Python, где требуется логирование, инициализируй логгер СТРОГО следующим образом:
    #      import logging 
    #      logger = logging.getLogger(__name__)
    #    - НЕ ИСПОЛЬЗУЙ `logging.basicConfig()` или прямое конфигурирование корневого логгера.
    #    - Базовую конфигурацию (уровень, форматтер для всего приложения) следует выносить в главный исполняемый файл (например, в блок if __name__ == "__main__":) или отдельный модуль конфигурации логирования, если он есть. Для этого модуля просто получай logger через getLogger(__name__).
    # 2.2 Общие рекомендации что именно логировать
    #    - Логируйте значения ключевых переменных на входе функции/метода и перед возвратом из них.
    #    - Логируйте переменные для IF-условий, если они определяют важные ветви логики.
    #    - Логируйте вызовы внешних сервисов или других значимых функций (до и после вызова с результатом).
    #    - Избегай черезмерного логирования, если логический блок не имеет сложной логики, то не добавляй больше одной строки в лог
    #    - Если логика блока кода очень проста, то лучше сделай еще один обработчик ошибок try... except в нем и записывай в лог возможные ошибки
    # 2.3   **СТРОГИЙ ФОРМАТ СТРОКИ ЛОГА:**
    #      `f"[{УРОВЕНЬ_БУКВАМИ}][{ИМЯ_ФУНКЦИИ_ИЛИ_МЕТОДА}][{ИМЯ_ТЕКУЩЕГО_ЛОГИЧЕСКОГО_БЛОКА}][{ТИП_ОПЕРАЦИИ}] Описание [СТАТУС]"`
    #    - Используйте уровни логирования осмысленно:
    #      - DEBUG: Для детальной отладочной информации, полезной разработчикам при анализе конкретного блока.
    #      - INFO: Для общих информационных сообщений о ходе выполнения (старт/стоп операций, успешные результаты шагов).
    #      - WARNING: Для потенциальных проблем или некритичных ошибок, которые не останавливают работу блока/функции.
    #      - ERROR: Для ошибок, которые помешали выполнению текущей операции в блоке, но функция/приложение может продолжить работу.
    #      - CRITICAL: Для очень серьезных ошибок, которые могут привести к остановке всего приложения.
    #      Примеры ТИП_ОПЕРАЦИИ: Params, ConditionCheck, ReturnData, CallExternal, StepComplete, ExceptionCaught.
    #      Примеры STATUS: SUCCESS, FAIL, ATTEMPT, INFO, VALUE, ERROR_STATE.

    #START_[BLOCK_NAME_1]: [Краткое описание назначения блока 1, на русском.]
    # ... код блока 1 ...
    condition_result = (argument1 > 10) # Пример условия
    logger.debug(f"[DEBUG][{FunctionName}][BLOCK_NAME_1][ConditionCheck] Результат условия (argument1 > 10): {condition_result} [{ 'SUCCESS' if condition_result else 'FAIL' }]")
    if condition_result:
        # ...
        pass
    #END_[BLOCK_NAME_1]

    #START_[BLOCK_NAME_2]: [Краткое описание назначения блока 2, на русском.]
    # ... код блока 2 ...
    #   #START_[NESTED_BLOCK_2_1]: [Описание вложенного блока, на русском.]
    #   ... код вложенного блока ...
    #   logger.info(f"[INFO][{FunctionName}][NESTED_BLOCK_2_1][StepComplete] Вложенный блок выполнен успешно [SUCCESS]")
    #   #END_[NESTED_BLOCK_2_1]
    # ... продолжение кода блока 2 ...
    #END_[BLOCK_NAME_2]

    # ... другие логические блоки ...

    #START_[RETURN_BLOCK]: [Краткое описание, например, Подготовка и возврат результата, на русском.]
    result_value = "SomeResult" # Пример результата
    # ... код формирования результата ...
    logger.debug(f"[DEBUG][{FunctionName}][RETURN_BLOCK][ReturnData] Возвращаемое значение: {result_value} [VALUE]")
    #END_[RETURN_BLOCK]

    return result_value

# END_FUNCTION_[FunctionName]

# START_CLASS_[ClassName]
# CONTRACT:
# PURPOSE: [Краткое описание ответственности класса, на русском.]
# ATTRIBUTES:
#   - [имя_атрибута1]: [ТипДанных] - [Описание, на русском.]
#   - ...
# KEY_METHODS:
#   - [имя_метода1()]: [Краткое описание того, что делает метод, на русском.]
#   - ...
# KEYWORDS: [Keyword1, Pattern2 (e.g., Singleton, Factory), Concept3]
# LINKS: [RelatedClass1, ModuleUsedInternally2]

class [ClassName]:
    """
    [Однострочное, очень краткое описание функции на русском - для быстрого понимания и векторного поиска.]  
    """

    # Описание конструктора и методов делается аналогично шаблону для функций

# END_CLASS_[ClassName]

